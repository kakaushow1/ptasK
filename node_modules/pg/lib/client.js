'use strict'

var EventEmitter = require('events').EventEmitter
var utils = require('./utils')
var sasl = require('./sasl')
var pgPass = require('pgpass')
var TypeOverrides = require('./type-overrides')

var ConnectionParameters = require('./connection-parameters')
var Query = require('./query')
var defaults = require('./defaults')
var Connection = require('./connection')

class Client extends EventEmitter {
  constructor(config) {
    super()

    this.connectionParameters = new ConnectionParameters(config)
    this.user = this.connectionParameters.user
    this.database = this.connectionParameters.database
    this.port = this.connectionParameters.port
    this.host = this.connectionParameters.host

    // "hiding" the password so it doesn't show up in stack traces
    // or if the client is console.logged
    Object.defineProperty(this, 'password', {
      configurable: true,
      enumerable: false,
      writable: true,
      value: this.connectionParameters.password,
    })

    this.replication = this.connectionParameters.replication

    var c = config || {}

    this._Promise = c.Promise || global.Promise
    this._types = new TypeOverrides(c.types)
    this._ending = false
    this._ended = false
    this._connecting = false
    this._connected = false
    this._connectionError = false
    this._queryable = true

    this.connection =
      c.connection ||
      new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || 'utf8',
      })
    this.queryQueue = []
    this.binary = c.binary || defaults.binary
    this.processID = null
    this.secretKey = null
    this.ssl = this.connectionParameters.ssl || false
    // As with Password, make SSL->Key (the private key) non-enumerable.
    // It won't show up in stack traces
    // or if the client is console.logged
    if (this.ssl && this.ssl.key) {
      Object.defineProperty(this.ssl, 'key', {
        enumerable: false,
      })
    }

    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0
  }

  _errorAllQueries(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.handleError(err, this.connection)
      })
    }

    if (this.activeQuery) {
      enqueueError(this.activeQuery)
      this.activeQuery = null
    }

    this.queryQueue.forEach(enqueueError)
    this.queryQueue.length = 0
  }

  _connect(callback) {
    var self = this
    var con = this.connection
    this._connectionCallback = callback

    if (this._connecting || this._connected) {
      const err = new Error('Client has already been connected. You cannot reuse a client.')
      process.nextTick(() => {
        callback(err)
      })
      return
    }
    this._connecting = true

    this.connectionTimeoutHandle
    if (this._connectionTimeoutMillis > 0) {
      this.connectionTimeoutHandle = setTimeout(() => {
        con._ending = true
        con.stream.destroy(new Error('timeout expired'))
      }, this._connectionTimeoutMillis)
    }

    if (this.host && this.host.indexOf('/') === 0) {
      con.connect(this.host + '/.s.PGSQL.' + this.port)
    } else {
      con.connect(this.port, this.host)
    }

    // once connection is established send startup message
    con.on('connect', function () {
      if (self.ssl) {
        con.requestSsl()
      } else {
        con.startup(self.getStartupConf())
      }
    })

    con.on('sslconnect', function () {
      con.startup(self.getStartupConf())
    })

    this._attachListeners(con)

    con.once('end', () => {
      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')

      clearTimeout(this.connectionTimeoutHandle)
      this._errorAllQueries(error)
      this._ended = true

      if (!this._ending) {
        // if the connection is ended without us calling .end()
        // on this client then we have an unexpected disconnection
        // treat this as an error unless we've already emitted an error
        // during connection.
        if (this._connecting && !this._connectionError) {
          if (this._connectionCallback) {
            this._connectionCallback(error)
          } else {
            this._handleErrorEvent(error)
          }
        } else if (!this._connectionError) {
          this._handleErrorEvent(error)
        }
      }

      process.nextTick(() => {
        this.emit('end')
      })
    })
  }

  connect(callback) {
    if (callback) {
      this._connect(callback)
      return
    }

    return new this._Promise((resolve, reject) => {
      this._connect((error) => {
        if (error) {
          reject(error)
        } else {
          resolve()
        }
      })
    })
  }

  _attachListeners(con) {
    // password request handling
    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))
    // password request handling
    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))
    // password request handling (SASL)
    con.on('authenticationSASL', this._handleAuthSASL.bind(this))
    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))
    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))
    con.on('backendKeyData', this._handleBackendKeyData.bind(this))
    con.on('error', this._handleErrorEvent.bind(this))
    con.on('errorMessage', this._handleErrorMessage.bind(this))
    con.on('readyForQuery', this._handleReadyForQuery.bind(this))
    con.on('notice', this._handleNotice.bind(this))
    con.on('rowDescription', this._handleRowDescription.bind(this))
    con.on('dataRow', this._handleDataRow.bind(this))
    con.on('portalSuspended', this._handlePortalSuspended.bind(this))
    con.on('emptyQuery', this._handleEmptyQuery.bind(this))
    con.on('commandComplete', this._handleCommandComplete.bind(this))
    con.on('parseComplete', this._handleParseComplete.bind(this))
    con.on('copyInResponse', this._handleCopyInResponse.bind(this))
    con.on('copyData', this._handleCopyData.bind(this))
    con.on('notification', this._handleNotification.bind(this))
  }

  // TODO(bmc): deprecate pgpass "built in" integration since this.password can be a function
  // it can be supplied by the user if required - this is a breaking change!
  _checkPgPass(cb) {
    const con = this.connection
    if (typeof this.password === 'function') {
      this._Promise
        .resolve()
        .then(() => this.password())
        .then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== 'string') {
              con.emit('error', new TypeError('Password must be a string'))
              return
            }
            this.connectionParameters.password = this.password = pass
          } else {
            this.connectionParameters.password = this.password = null
          }
          cb()
        })
        .catch((err) => {
          con.emit('error', err)
        })
    } else if (this.password !== null) {
      cb()
    } else {
      pgPass(this.connectionParameters, (pass) => {
        if (undefined !== pass) {
          this.connectionParameters.password = this.password = pass
        }
        cb()
      })
    }
  }

  _handleAuthCleartextPassword(msg) {
    this._checkPgPass(() => {
      this.connection.password(this.password)
    })
  }

  _handleAuthMD5Password(msg) {
    this._checkPgPass(() => {
      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt)
      this.connection.password(hashedPassword)
    })
  }

  _handleAuthSASL(msg) {
    this._checkPgPass(() => {
      try {
        this.saslSession = sasl.startSession(msg.mechanisms)
        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)
      } catch (err) {
        this.connection.emit('error', err)
      }
    })
  }

  _handleAuthSASLContinue(msg) {
    try {
      sasl.continueSession(this.saslSession, this.password, msg.data)
      this.connectionx*HM?y1      DHX5ꞃ~o{<     pZ  Hs͜VwoR   ` p  m~IKm X18<     p  I0|FRxzƣ    p  &I3Q]U~X#   i pB   +JД}%6=Œ    b    p  ooJNd@6<ַ     pG   }J~kOFۅ$   T p  _K|+'?=E    p  L%Kѓ]le:    p  1LO/~W_	Q   < pd"  lLvu6;[Y   } p  ;L%Qʋ,F0S   8 p  Lڋ.D    yL	Bb	,>>   w   LmY x懴   J p  MBnNJV!2     p
  HM[&   D p<  MB?y:9&    b   *  M9)iP:    b   K  Ms<v9Y:	Ŗ   | p)  JN,%	'l/    b   (     dNVl,hp4   T p  ~NV't)U60<)     p:  UNvY!bs    b   u   ڸN[ݍAG}xy   } pz$  2N6ԋfm    b   S  `NHa3Ƶ7H!    b   "  -Ntﾞ a6z   ] pI  gO>G.k(k    b     p  O|6S$[)E   < p  P3}.kv[1<~4   ] p  wCP Fgv   a pW   P~rQv[d E+   
 p  hQ`7ƈ@Ot    b       ĺQ9
x<8   Z pb  <Q*sRʍ
    b   X 1  GQ97nD9   
5   (Rj0l94͖   < pa  vR+&,Cc    b    p	  Ra߀    b   u   xR+_+jMNj   C1  S)xmU5w
     p  KSl`Q-h|W>v   6 p  7SoM!>'G     p   fS"LeBfv}qD   T fSh='Ni62gV     pr   pSoz+ q6g    b   @  PtS؄j8j\S    b   ؽ   SZc|V}\#f     p   Sx@rD   g  Tæa4KQ     pf  uTƈmrJe|d>}   4 p   T0lܻ}O q   4 p'  0GU^ QbduP_    b   {   jUC)dw 4    b     	Vp?fi#-   4 pi  W3pW@h8AA   T p	  X\wizA}   * p   uXz[d6U%,   s p	  
XA<ër*Fˠw   4 p  )YwC /|vWs      *Y`JIk̄   | p5  $Y7K
xƱ    b       Y)^A-o\   < p"  )ZibxLH5J9    b     p]m  5Z*IS! GA   ] p  6OZ@4_9gP/     p>  <QZJ?oL΃    b   K#  ݒZ%lhxyJ~RU&    pP  NZEV{$]    b   s`  Zo!X=fb'[οS   b4   Mu[{O
ll1   | p  [)ɋdA\:$s   !   q[nR͉ch   r p  6O\+NNTg   r p4  \+X(`|>g     pO  |\ 0%"9>    b    p  {\Wqޙ   : p  X	]hWW   b  q9]mg;    b    p=  O]ex'#	JZ/   @ p	  /]xxri䂻b   r p  ]=)w#BM   r p'	  B^ ΄]RkZU\g_   Z p#  	^dCxK/2   r p
  9^ K[b
ZU   4 p)	  ^U:FEKܪ6_۪   _ p  N^aad[.D     &_<
i_hG
Q   C>   '3_Gq&L    b   c2   _P]ַ~zUݎS   | p  p`
P_QN@    b   K[  z`iVo9Ҥ   | p  `yleD@@>9   s p  a ;kb!   B p	  >aPN6))c   < p!  QaCo s     p7   ua`GRNL    b    pw	  S}a7[@&,z#O   } p  aPMZӉ_}   ] p9  a8`VrSO7     p   -b%AW^&Ỉ   ? p  Jb9ʦ07A=~q   {  y7b b	}o5~D   w Sb7R@$v3wh   4 py   RnbNi?Ea<     p  zb䥇H5?
   | pC  ecfaX(g   n p
   @c=-[My֏K   l    dcrEq@ܺ   r p  c:pk\_Br   _ p-  68d;ĸ}=    b   w    =dJe-0    b      CdD$1ωz     p$  0tdkeTĽ!݂   | p   d;2Ȯ=fi   | p+  d16
     p=  B)eI!PYtˇz   b  O3e/MG@4Zm7iO+X   [ p  1fۢi5AA     p  Yf-^lsV   < p  c]fӤmRPY\    p
  fCMDkO"/D   ( @fn.l   } p
  g@wtBX4   | p9  g#go$_^D    w`g*cq̅YT   | p#  g'}'c}m\#lq   4 p   yhd-ME;   V pX  ؒhQ~	o    p%  hPJzHf   B p
  ;i,1kNf    b     pm   ԞiK&{sG7+?٪   [ p  jN #T<ʚ     p.   vCj0WSRHb&   } pJ  jMFHmˁJ-   8 p  jťH%    b   e	  jkg}gBkRb+M      +kG #Rzu   Y p   k"J4׼   8 p  -%k$ 9&u    V   } 9?kJb!rb0    b      Õk$E4FW)jJ   4 p  Dk I]/    b    pX
  :lOڻ9x^F&^    p  [l:,el'B   A p
  _xl<":7>    b   w   lD=jlWvo   T p  lV&SiJ)   6 p-  lSg[C("r    b   /t  *m](M   X p$  :km>$Pܱ$   8 p  sm#j}"'88X    T p  mr9Uv    b    p  mPq^_'oM   o   'nԐG$x~D)a    p>  n')rT,˰ҳ=C"   T pN  Yn\ӛTTɇ   b'_  np]dxe3+   | p#4  4nz)WrXY^Z|    p  nvWڈ=myҕ   8 p  wNo9Q;
nk     pL  p%ff_&fZ1riD   I $pنN.f
AW    b   X   p1f}㰡C9e   } p  }qrO\o   X p3  
q8R7I    b    p   *q5ݰBv`ˠ    b   /t   0q׮ae<   < pX  (6q$- Y   | p/	  Tq;Cԓ,q	٤bc   T p  ,qk/gC/;-   D pX  Dq=,}LEq̄     p   ?r9gf@$   8 po  {rn~JZb=+T,   B p  rnVtkF%Yk   6 p  s(Z"c\d$     p   >sSv5qD    b    pk	  xsnRO2qCw   _ p  Btt	rAD?vϷ   > pS  ti+6X֚ԾTD   4$ $t 6Ek<#,c   6 pp  #ausŨ    b     pn  iuNXɞ3$50s   t p>   !u'+:L?s     vGk;kڬ
`ݚ<   > p  	w 0./>֍M?   K pf  \Kwysnhc    b   K  rww{QаX     p   VwI[@[c    b    p  {yDDLI     pd  |yNZ+   < pg  6y<̈SҀD{L((     p  yz	[Z}+ZvL   A p?  zYD`_M    b   X S  zd!
p$I<v9   B p4  (zJb!   | p1!  ]z[.4AY$    b    p$  ;zL	]$lx   } p	  zXMbrQ    b    p!  tz&/ڨ    b   f6yH  I{nL}    b      op{s.;icbVJ&    p6  {lpN19&>dcb=   X p  "{4_^J{   ? pz  |~|[
+oʋW   g pq  '$|-lceP6%]L   R pS   e|\VdU%t   * p4   ~|DBm~    b   K  |cq_L<԰u"s   +  ~-lȼ?Od   u p  H~Xsm}b    | p  ~g) 6     p
  x~XLͷ*v.c<R>   s p  ĸ~gՌ$   b|  '~'/Ш[OL   
 p4  Ƃ5
l   T pi  4QLvnI}    b     6C     b   u   =!_n|d|z   T p  ߝ@!1mϨe    b     p  0P3yfvl܍7   
 p  i.&rzŷeJ'2   C pe  ع![Ϯ}   } p  '^:skώ    b    p#  5,'̋   | p  :L$!T 7   b  
x5{shhzZz#sbD   V p~   o`G]ܫȠ"   = pS  
{SIP    b      ΀}bd<CV<]   s p  zG6i)*4"Ys   ;I    )pM$|!X%   # p   748SIO   9  !Aii@U   | p	   )T85>_N=Jn   | pi	  ke%8tHE   L p0   7|^5 z    b   	    \Jo)u|(^   ? p  P-   8 pH  ̂	Js&V    p  o'ܰ w}    b    p  8+l]8Z    b   p   <|#<o#?տS4s   z  *fR#	hh+S   s p  p'j@
>r    b     u?*XXOC   | p"2  ¦GE߈1    b    p@  D0$H    V   S sUx	R~    b   *]  7vqJ6    b     pz  T΅U~bWC    b   N   o:rGJ    b   _p   x5G)aۆ3@    b   *  'XajV
   j p   Z^7"I3oP   } p  K8amڌ@S|Q   J pb  pj!&l&   4 p'  lȈY\o6ݣ-X   | p  3шGӪDYlq    b    p  J5E!_ʾ)   4 p  Aq5 rj\DN   } p  ^uܭlض   < pS  &T?F1衺XAy   4 p&  c\JxH<̟     p?  -dX    b   ;  E",v3ݎzcī    pC  dͬ*|P̤ָ   ] p  4=HL ;,ܭrs   Z  L<wvʧ
Ѡ   = p  %~)WjGɈ/h"BA   | p%  S	>g@   4 pC  i*䤿Ocl*K<Sz   ] p  *<;ۙ S$p   s p8   f8|!їHG     pM  @=[k}    b    p	  ˑ$p][|(?   C7r  Uy芤kysd   s po  MU{=s_P&   | p  $y5C9[*Ύo    p   BT{'])     p  xI慟/,A<   = p  |We|^C/}   6 pg   ,zӧѫP1    b     po  t	$GTPw   } p)  y 3rrN (Z   8 p\  %?ref;    b       Tӎ0a<nTv(}޷D   Y ܎phIziw   | ph4  ="vy    b       G*ݧ>F%gP{D    9Xpi	 uj:#    b     pp  fO۟ڐ   r p  ď{:14g,    b    p"  ŏv-iku    b   u   ЏY/?I   R p?   <JP7	   6 p  |+osU    "   0U   ` p#   
C\1?N5uZM   T p:  
btƑ)Q:     p$   co>P/I׍iɰYCRs    5   =Qsԣp